Query: How can I insert an element in array at a given position?
-----------------------------------------------------------------------

Rank:1 (https://stackoverflow.com/questions/27859771)
 Here is another linear solution. The code is longer than the one suggested in the leet code link, but I think it is easier to understand. It is based on a two observations: the number of steps required to reach the  i + 1  position is never less than the number of steps required to reach the  i  position and each element each element assigns its value + 1 to  i + 1 ... i + a[i]  segment. 

  public class Solution {
    public int jump(int[] a) {
        int n = a.length;
        // count[i] is the number of "open" segments with value i
        int[] count = new int[n];
        // the number of steps to reach the i-th position
        int[] dp = new int[n];
        Arrays.fill(dp, n);
        // toDelete[i] is the list of values of segments 
        // that close in the i-th position
        ArrayList<Integer>[] toDelete = new ArrayList[n];
        for (int i = 0; i < n; i++)
            toDelete[i] = new ArrayList<>();
        // Initially, the value is 0(for the first element).
        toDelete[0].add(0);
        int min = 0;
        count[0]++;
        for (int i = 0; i < n; i++) {
            // Finds the new minimum. It uses the fact that it cannot decrease. 
            while (min < n && count[min] == 0)
                min++;
            // If min == n, then there is no path. So we can stop.
            if (min == n)
                break;
            dp[i] = min;
            if (dp[i] + 1 < n) {
                // Creates a new segment from i + 1 to i + a[i] with dp[i] + 1 value
                count[dp[i] + 1]++;
                if (i + a[i] < n)
                    toDelete[i + a[i]].add(dp[i] + 1);
            }
            // Processes closing segments in this position.
            for (int deleted : toDelete[i])
                count[deleted]--;
        }
        return dp[n - 1];
    }
}
  

 Complexity analysis:  

 
  The total number of elements in  toDelete  lists is  O(n) . It is the case because at each position  i  at most one element is added. That's why processing all elements in all  toDelete  lists requires linear time.  
  The  min  value can only increase. That's why the inner  while  loop makes at most  n  iterations in total.   
  The outer  for  loop obviously makes  n  iterations. Thus, the time complexity is linear.  
 


-------------------------------------next answer-------------------------------------

Rank:2 (https://stackoverflow.com/questions/40388108)
 Given that you want to dynamically add elements, a  List  is probably the right data structure to use, not an array.  

  class example{
    public static void main(String[] args) {
        ArrayList<Integer> array = new ArrayList<>();
        array.add(2);
        array.add(3);
        array.add(4);
        array.add(5);
        array.add(6);
        array.add(7);

        int indexvalue = 2;
        Integer num = 8;

        array.add(indexvalue, num);
    }
}
  

 Here is the javadoc on the  add  method I used here to insert the element: http://docs.oracle.com/javase/6/docs/api/java/util/List.html#add%28int,%20E%29 

 See this post for the many reasons a list is better than an array for what you are trying to do: https://stackoverflow.com/questions/434761/array-versus-listt-when-to-use-which 


-------------------------------------next answer-------------------------------------

Rank:3 (https://stackoverflow.com/questions/20904059)
 Here is the simple arraylist example for insertion at specific index 

  ArrayList<Integer> str=new ArrayList<Integer>();
    str.add(0);
    str.add(1);
    str.add(2);
    str.add(3); 
    //Result = [0, 1, 2, 3]
    str.add(1, 11);
    str.add(2, 12);
    //Result = [0, 11, 12, 1, 2, 3]
  


-------------------------------------next answer-------------------------------------

Rank:4 (https://stackoverflow.com/questions/48900542)
 set method replaces the element in the specified position with the new element.
But in add(position, element) will add the element in the specified position and shifts the existing elements to right side of the array .  

  ArrayList<String> al = new ArrayList<String>();

    al.add("a");
    al.add(1, "b");
    System.out.println(al);

    al.set(0, "c");
    System.out.println(al);

    al.add(0, "d");
    System.out.println(al);
  

 ---------------Output ------------------------------------- 

 [a, b] 

 [c, b] 

 [d, c, b] 


-------------------------------------next answer-------------------------------------

Rank:5 (https://stackoverflow.com/questions/13812329)
 Its always a good practice to use  List  type when declaring  ArrayList . So instead of  

  ArrayList<ArrayList<String>>ar1 = new ArrayList<ArrayList<String>>();
  

 use 

  List<List<String>>ar1 = new ArrayList<List<String>>();
  

 You can easily add elements in the arraylist through .add(element) method. Read the ever helpful http://docs.oracle.com/javase/1.4.2/docs/api/java/util/List.html for the complete list of list methods. At first of course it is empty. To start populating it, you need to create a 1d arraylist 

  List<String> a = new ArrayList<String>()
a.add("element");
  

 Then add the 1d arraylist in you 2d arraylist 

  ar1.add(a);
  

 To insert an element in a 2d list, you must access the position of the 1d arraylist where you want to insert then do an  .add(String) . 

  ar1.get(0).add("newly added element"); //will get the first list then append the string to that list
  

 Same as, to get an element in the 2d list 

  ar1.get(0).get(0); //will get the first lis then get the first element of the pulled list
  



