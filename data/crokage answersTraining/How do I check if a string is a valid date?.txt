Query: How do I check if a string is a valid date?
-----------------------------------------------------------------------

Rank:1 (https://stackoverflow.com/questions/14728229)
 You can check that the String follow the exact format of 4 digits, a dash  - , 2 digits, a dash  -  and 2 digits with @burning_LEGION's regex. However, it doesn't check whether the String represents a valid date. You can specify  9999-99-99  and it will pass the validation. 

 Using http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html is the proper method to check that the String is a valid date and it follows a given format of representation. SimpleDateFormat, apart from http://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#format%28java.util.Date%29, can also be used to parse Date from String: http://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#parse%28java.lang.String%29, http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#parse%28java.lang.String,%20java.text.ParsePosition%29. 

 By default, SimpleDateFormat is  lenient , which means it will allow nonsensical dates such as  2013-025-234  to pass. Use http://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#setLenient%28boolean%29 to  false  will solve this problem. 

 However, another problem is that it will also ignore any garbage data that is after a valid date (e.g.  2012-03-23garbage#$%$#% ). Setting lenient doesn't solve this problem. We need to check the last position with  parse(String, ParsePosition)  method. 

  SimpleDateFormat dateFormatter = new SimpleDateFormat("yyyy-MM-dd");
// Make the parsing strict - otherwise, it is worse than regex solution
dateFormatter.setLenient(false); 

Date date = null;
ParsePosition pos = new ParsePosition(0);

date = dateFormatter.parse(inputString, pos);

if (date != null && pos.getIndex() == inputString.length()) {
    // These 3 points are ensured:
    // - The string only contains the date.
    // - The date follows the format strictly.
    // - And the date is a valid one.
} else {
    // Valid date but string contains other garbage
    // Or the string has invalid date or garbage
}
  

  SimpleDateFormat  will allow  2013-1-5  to pass, which I think is a reasonable leniency. If you don't want this, you can do a check against the regex before plugging the String into the  parse  method. 


-------------------------------------next answer-------------------------------------

Rank:2 (https://stackoverflow.com/questions/19492462)
 Use  DateFormat#parse(String) : 

  Date date = dateFormat.parse("2013-10-22");
  


-------------------------------------next answer-------------------------------------

Rank:3 (https://stackoverflow.com/questions/37678875)
  CEST  is  Central European Summer Time . It is the same as  CET  with daylight savings into effect.  

 Try out the following code stuffs using  EEE MMM dd HH:mm:ss Z yyyy  date format 

  DateFormat dateFormat = new SimpleDateFormat("EEE MMM dd HH:mm:ss z yyyy", Locale.US);
Date date = dateFormat.parse("Mon Jun 06 18:35:01 CEST 2016");
  


-------------------------------------next answer-------------------------------------

Rank:4 (https://stackoverflow.com/questions/20143333)
 You can check the format of the date by using a http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html like this, because using  regex  for validating date formats is a very bad practice, IMHO. 

  String strDate = "2010.12.25";
DateFormat df = new SimpleDateFormat("yyyy.MM.dd");
try {
    Date date = df.parse(strDate);
    // If it comes here, then its a valid format
} catch (ParseException pe) {
    // If it comes here, then its not a valid date of this format.
}
  


-------------------------------------next answer-------------------------------------

Rank:5 (https://stackoverflow.com/questions/7882065)
 Use http://download.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html: 

  String start_dt = "2011-01-01";
DateFormat formatter = new SimpleDateFormat("yyyy-MM-DD"); 
Date date = (Date)formatter.parse(start_dt);
SimpleDateFormat newFormat = new SimpleDateFormat("MM-dd-yyyy");
String finalString = newFormat.format(date);
  



