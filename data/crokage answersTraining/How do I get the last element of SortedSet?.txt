Query: How do I get the last element of SortedSet?
-----------------------------------------------------------------------

Rank:1 (https://stackoverflow.com/questions/14040470)
  add()  method of  LinkedHashSet  do not call  contains()  internally else your method would have been called as well.  

 Instead of a  LinkedHashSet , why dont you use a  SortedSet  with a case insensitive comparator 
? With the http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html#CASE_INSENSITIVE_ORDER comparator 

 Your code is reduced to 

  public static List<String> removeDupList(List<String>list, boolean ignoreCase){
    Set<String> set = (ignoreCase?new TreeSet<String>(String.CASE_INSENSITIVE_ORDER):new LinkedHashSet<String>());
    set.addAll(list);

    List<String> res = new ArrayList<String>(set);
    return res;
}
  

 If you wish to preserve the Order, as @tom anderson specified in his comment, you can use an auxiliary LinkedHashSet for the order.  

 You can try adding that element to TreeSet, if it returns true also add it to LinkedHashSet else not. 

  public static List<String> removeDupList(List<String>list){
        Set<String> sortedSet = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
        List<String> orderedList = new ArrayList<String>();
        for(String str : list){
             if(sortedSet.add(str)){ // add returns true, if it is not present already else false
                 orderedList.add(str);
             }
        }
        return orderedList;
    }
  


-------------------------------------next answer-------------------------------------

Rank:2 (https://stackoverflow.com/questions/6460391)
 You will get a  java.util.ConcurrentModificationException  if you add an element into the TreeSet inside while loop. 

  Set<String> ts=new TreeSet<String>();
ts.addAll(Arrays.asList(new String[]{"abb", "abd", "abg"}));
Iterator<String> itr=ts.iterator();
while(itr.hasNext()){
    String s = itr.next();
    System.out.println("s: " + s);
    if (s.equals("abd"))
        ts.add("abc");
}
  

 Output</h3>

  Exception in thread "main" java.util.ConcurrentModificationException
  


-------------------------------------next answer-------------------------------------

Rank:3 (https://stackoverflow.com/questions/8772274)
 You will need to cast back to TreeSet, as Set's don't have any order. 

  listOfSources.remove( ((TreeSet) listOfSources).last() );
  


-------------------------------------next answer-------------------------------------

Rank:4 (https://stackoverflow.com/questions/8360827)
 A  Collection  is not a necessarily ordered set of elements so there may not be a concept of the "last" element.  If you want something that's ordered, you can use a  SortedSet  which has a  last()  method.  Or you can use a  List  and call  mylist.get(mylist.size()-1);  

 If you  really  need the last element you should use a  List  or a  SortedSet .  But if all you have is a  Collection  and you really, really,  really  need the last element, you could use  toArray()  or you could use an  Iterator  and iterate to the end of the list.   

 For example: 

  public Object getLastElement(final Collection c) {
    final Iterator itr = c.iterator();
    Object lastElement = itr.next();
    while(itr.hasNext()) {
        lastElement = itr.next();
    }
    return lastElement;
}
  


-------------------------------------next answer-------------------------------------

Rank:5 (https://stackoverflow.com/questions/8772337)
 As an alternative you can set listOfSources as a SortedSet 

  SortedSet<String> listOfSources = new TreeSet<String>();
  

 Then you can use  last()  method without casting to TreeSet 

  listOfSources.remove(listOfSources.last());
  

 I think that this is a preferred approach since you suppose that your Set has an order. 



